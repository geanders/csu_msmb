---
title: Exercise solution for Chapter 9
author: Daniel Dean
date: '2020-04-17'
slug: exercise-solution-for-chapter-9
categories:
  - exercises
  - Chapter 9
tags:
  - exercises
  - Chapter 9
subtitle: ''
summary: ''
authors: [daniel-dean]
lastmod: '2020-04-20T20:22:07-07:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---

## Exercise 9.2

> "Correspondence Analysis on color association tables:
Here is an example of data collected by looking at the number of Google hits resulting from queries of pairs of words. The numbers in Table 9.4 *[not reporduced]* are to be multiplied by 1000. For instance, the combination of the words “quiet” and “blue” returned 2,150,000 hits. Perform a correspondence analysis of these data. What do you notice when you look at the two-dimensional biplot?"

In this exercise, we are essentially asked to repeat the correspondence analysis process seen in section 9.4.2, this time using associations color and sentiment terms in search engine queries, rather than hair and eye color. The same general steps can be repeated without many changes.

# Step 1: Loading libraries
```{r libraries, message = FALSE, warming = FALSE}
library(ade4)
library(sva)
library(tidyverse)
library(factoextra)
library(janitor) #optional; function `clean_names()` makes column names easier to work with
library(ggplot2)
library(ggrepel)
```

# Step 2: Two ways to load data:

At least working from the online version of the tex,t there are two ways to obtain (roughly) equal data for this exercise. One option is to copy table 9.4 directly from the book into Excel, shift the header one cell to the right to align columns with their proper names, export a .csv (`ex_9.2_color_table.csv` in this example), and load it into R using a command like:

```{r copy_paste_method, eval = FALSE}
color_matrix <- read_csv("example_datasets/ex_9_2_color_table.csv", col_names = TRUE) %>%
  column_to_rownames(var = 'X1') %>%
  as.matrix
```

Something to note is that this data is rounded to units of thousands (e.g. "19" is ~19,000), while the course data in the downloadable `data` file gives more-precise values. I don't know that this would disrupt any major correlations, but it could cause some minor discrepancies on comparison. 


Alternatively, the file is included in the course data as `colorsentiment.csv`, although in a different, three-column format:

```{r course_data}
head(read_csv("example_datasets/colorsentiment.csv"))

```

This can be converted to match our correspondence table format using the `pivot_wider` function and other `tidyverse` formatting tools: 

```{r reformat, message = FALSE}
color_matrix <- read_csv("example_datasets/colorsentiment.csv") %>%
  janitor::clean_names() %>% #standardizes column name format
  arrange(desc(results)) %>% # Rearranging to match row/col order in table 9.4
  pivot_wider(names_from = x, values_from = results) %>% # converts colors from column entries (`x`) to column names
  column_to_rownames(var = 'y') 

color_matrix

```


# Correspondence Analysis (following section 9.4.2 as a model)

Setting up the correspondence analysis object using the correspondence analysis `dudi` function from the `ade4` package:
```{r}
color_matrix_ca <- dudi.coa(color_matrix, n = 2, scannf = FALSE) # scannf = FALSE stops automatic printing of eigenvalues
```

This creates a  special "*Du*ality *Di*agram" list object (used by the `ade4` package for correspondence analysis ,but also principle component analysis and other methods) containing a variety of data generated by the analysis; the call `?dudi()` will give a list of what each component contains (axis weights, point coordinates, etc.).Sttored features include as the base data table (`tab`), a vector of eigenvalues (`eig`), and a variety of information on row and column data (e.g. weights, coordinates, and principle components).


Question 9.2 specifies that we use two dimensions, but visualizing the eigenvalues with  the `factoextra` package confirms that this is a good representation of the system, with almost all variance being explained by the first two dimensions:

```{r}
fviz_eig(color_matrix_ca, geom = 'bar') # visualizing eigenvalues 
```

Following the book's example in 9.4.2, we can explicitly calculate a residual matrix, which shows the difference between expected (assuming random distribution) and observed values for given row/column intercepts, in the following steps. This doesn't feed into visualizations, but it may be helpful to have a quantitative reference for residuals:

```{r residual_matrix}
rowsums_colors <- as.matrix(apply(color_matrix, 1, sum))
colsums_colors <- as.matrix(apply(color_matrix, 2, sum))
expected_colors <- rowsums_colors %*% t(colsums_colors) / sum(colsums_colors) # using matrix multiplication to see what 
# "average" values should look like if row and column sums are distributed evenly across the dataset

#sum((color_matrix - expected_colors)^2 / expected_colors)

residual_table_colors <- round(t(color_matrix - expected_colors)) # subtracting the "expected" matrix from the observed  
#values to see discrepancies

(residual_table_colors)
```

Here, we can see that, for instance, the combination of "happy" and "black" in searches occurs significantly more often (~26,000,000 additional instances) than we'd expect given no correlations between colors and sentiments, while e.g. "happy" and "grey" is much rarer. 


To take these patterns more intuitively, We can use a mosaic plot to visualize the proportional distribution of color/sentiment terms in searches (e.g. "back" and "happy" are both popular terms, so could be expected to occur more frequently than e.g. "perplexed" and "purple" in any case), as well as color coding for residuals:

# *Note: for some reason I'm having issues getting the mosaic plot's color coding to work here; it shows standardized residuals as uniformly either >4 or <-4, which didn't occur when rendering directly in R*

```{r}
  #For some reason this is 'flattening'  color coding to <-4 or >4 in the final render, but shows intermediate levels in R Studio

mosaicplot(t(color_matrix), las = 2, shade = TRUE, type = 'pearson')
  #transposing is just aesthetic; seems easier to follow with sentiments on the y axis
```

From this pattern, it's easier to see that, for instance, `black` has an inverse pattern for residuals than most colors, being higher than expected with "happy" and generally lower for the other colors. Following similar comparisons, we can see that `white`, `green`, and `blue` all act more similarly to each other than other colors, as do `orange`, `purple`, and `grey` (although both of these latter sets are closer to each other than to `black`). Looking at sentiment words, we can see that `happy` is again quite distinct from the other terms, while e.g. `perplexed`, `depressed` and `virtuous` (aside from being quite rare) share a relative dearth of cooccurrences with the `orange-purple-grey` group. Based on this, we could expect a two-dimensional representation to have the largest difference between `black`/`happy` and the rest of the terms, with `green-blue-white` and `organe-purple-grey` forming their own, less-distinct, clusters. 

Finally, we can use the `factoextra` biplot visualization function for correspondence analysis to see our biplot for sentiment and color searches. I thought using the option to represent one as vector arrow, rather than points, also improves legibility (e.g. the relationship between `angry` and `orange`/`purple` became more obvious):

```{r fviz biplot}
fviz_ca_biplot(color_matrix_ca, arrows = c(FALSE, TRUE), repel = TRUE)
```


As we can see, sentiment and color groups show similar relationships from what we might expect comparing patterns of positive/negative residuals in the mosaic plot. However, this makes it easier to see some patterns, such as the strong  opposition between `black` and `grey` on dimension 1, or the fact that most of dimension 2 is due to the differences of `green-white-blue` and `perplexed-depressed-virtuous` from the rest of the data. Another advantage is with rarer groups--e.g. `virtuous` and `depressed` behave more like `happy` than `perplexed` (or the rest of the sentiments) with respect to `black`, `grey`, and to a lesser extent `orange/purple`. A minor point is that this representation slightly exaggerates the proportional role of the 2nd dimension (20.4% variance explained vs 76.2% for the first dimension), which we could somewhat address by (roughly) doubling the x:y ratio of the figure.

# Plotting directly with `ggplot`:

While `factoextra` uses custom functions to streamline the process, it's possible to approximate the same visualization using `ggplot` and components of the `dudi` object. In the `color_matrix_ca` object, the 'row' and 'column' factor coordinates (emotion and color, respectively) are stored at `.$li` and `.$co`, This allows direct plotting; you could also look at e.g. normalized scores in `.$l1` and `.$c1` as well. I was able to get a general sense of how the `factoextra` authors approached this using the call `View(fviz_ca_biplot)` to pull up the function's R code; this ultimately pointed to the more fundamental `fviz` function. 

```{r ggplot_version}
#Single plots: (roughly equivalent to default output for `fviz_ca_col` and `fviz_ca_row`)

color_nmds <- color_matrix_ca$co %>%
  ggplot() + 
  aes(x = Comp1, y = Comp2) +
  geom_point(color = 'blue') +
  geom_text(label = rownames(color_matrix_ca$co), nudge_y = 0.01, color = 'blue')

color_nmds

emotion_nmds <- color_matrix_ca$li %>%
  ggplot() + 
  aes(x = Axis1, y = Axis2) +
  geom_point(color = 'red') +
  geom_text(label = rownames(color_matrix_ca$li), nudge_y = 0.01, color = 'red')

emotion_nmds

# Biplot (there are probably more efficient/correct approaches)

#manually joining the two datasets using a common index (generates a partial row of NAs, with 8 sentiments and 7 colors)

color_component <- color_matrix_ca$co %>%
  rownames_to_column(var = "color") %>%
  rownames_to_column(var = "index")

emotion_component <- color_matrix_ca$li %>%
  rownames_to_column(var = "emotion") %>%
  rownames_to_column(var = "index")

biplot_composite <- color_component %>%
  full_join(emotion_component, by = "index")

(biplot_composite)

biplot_composite_plot <- biplot_composite %>%
  ggplot() +
  aes(x = Comp1, y = Comp2) +
  geom_point(color = 'red') +
  geom_text(label = biplot_composite$color, nudge_y = 0.01, color = 'red') +
  geom_point(aes(x = Axis1, y = Axis2), color = 'blue') +
  geom_text_repel(aes(x = Axis1, y = Axis2), label = biplot_composite$emotion, nudge_y = 0.01, color = 'blue') +
  geom_hline(yintercept = 0, lty = 2) +
  geom_vline(xintercept = 0, lty = 2) +
  labs(x = paste0("Dim1(",round(color_matrix_ca$eig[1]/sum(color_matrix_ca$eig)*100, 1),"%)"),
       y = paste0("Dim2(",round(color_matrix_ca$eig[2]/sum(color_matrix_ca$eig)*100, 1),"%)")) # eeling lazy about figuring out how they render vectors in `fviz()` function; it seems to be a line from (0,0) to user-specified points, with an arrow tip rendered on the end.

biplot_composite_plot
```